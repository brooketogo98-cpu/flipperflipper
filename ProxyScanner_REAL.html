<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProxyAssessmentTool - REAL Proxy Scanner with Live Feed</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --discord-dark: #23272A;
            --discord-darker: #2C2F33;
            --discord-light: #99AAB5;
            --discord-blue: #7289DA;
            --discord-green: #43B581;
            --discord-red: #F04747;
            --discord-yellow: #FFD700;
            --discord-orange: #FAA61A;
            --discord-purple: #9B59B6;
        }
        
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Arial, sans-serif;
            background: var(--discord-darker);
            color: #FFFFFF;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Header */
        .header {
            background: var(--discord-dark);
            padding: 15px 20px;
            border-bottom: 3px solid var(--discord-blue);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .logo h1 {
            font-size: 24px;
            color: var(--discord-blue);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .version {
            background: var(--discord-blue);
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: normal;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--discord-green);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background: var(--discord-blue);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        button:hover {
            background: #5B6EAE;
            transform: translateY(-1px);
        }
        
        button:disabled {
            background: #4A4D52;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        button.stop {
            background: var(--discord-red);
        }
        
        button.mobile {
            background: var(--discord-purple);
        }
        
        /* Layout */
        .main-container {
            display: grid;
            grid-template-columns: 1fr 400px;
            height: calc(100vh - 70px);
        }
        
        /* Left Panel */
        .left-panel {
            display: flex;
            flex-direction: column;
        }
        
        /* Stats Bar */
        .stats-bar {
            background: var(--discord-dark);
            padding: 15px 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 11px;
            color: var(--discord-light);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-item.tested .stat-value { color: var(--discord-blue); }
        .stat-item.working .stat-value { color: var(--discord-green); }
        .stat-item.mobile .stat-value { color: var(--discord-purple); }
        .stat-item.socks5 .stat-value { color: var(--discord-yellow); }
        .stat-item.low-fraud .stat-value { color: var(--discord-orange); }
        .stat-item.speed .stat-value { color: #3498DB; }
        
        /* Map Container */
        #map {
            flex: 1;
            background: var(--discord-dark);
            position: relative;
        }
        
        /* Right Panel - Live Feed */
        .live-feed {
            background: var(--discord-dark);
            border-left: 1px solid rgba(255,255,255,0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .feed-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .feed-title {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .live-indicator {
            width: 8px;
            height: 8px;
            background: var(--discord-red);
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Feed Filters */
        .feed-filters {
            padding: 10px 15px;
            background: rgba(0,0,0,0.2);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .filter-chip {
            background: rgba(255,255,255,0.1);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .filter-chip.active {
            background: var(--discord-blue);
        }
        
        .filter-chip:hover {
            background: rgba(255,255,255,0.2);
        }
        
        /* Feed Items */
        .feed-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .feed-item {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            font-size: 13px;
            animation: slideIn 0.3s ease;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .feed-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(-2px);
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .feed-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .feed-ip {
            font-family: 'Consolas', monospace;
            font-weight: bold;
            color: white;
        }
        
        .feed-status {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .feed-status.working { background: var(--discord-green); }
        .feed-status.dead { background: var(--discord-red); }
        .feed-status.testing { background: var(--discord-yellow); color: #000; }
        
        .feed-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
            font-size: 11px;
            color: var(--discord-light);
        }
        
        .feed-detail {
            display: flex;
            justify-content: space-between;
        }
        
        .feed-detail-value {
            color: white;
            font-weight: 500;
        }
        
        /* Mobile Tag */
        .mobile-tag {
            background: var(--discord-purple);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
        }
        
        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--discord-green);
            color: white;
            padding: 15px 20px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
            animation: slideUp 0.3s ease;
            z-index: 1000;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(114, 137, 218, 0.3);
            border-top-color: var(--discord-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }
            
            .live-feed {
                position: fixed;
                right: -400px;
                top: 70px;
                width: 400px;
                height: calc(100vh - 70px);
                transition: right 0.3s ease;
                z-index: 999;
            }
            
            .live-feed.open {
                right: 0;
            }
            
            .toggle-feed {
                display: block !important;
            }
        }
        
        .toggle-feed {
            display: none;
            position: fixed;
            right: 10px;
            bottom: 10px;
            background: var(--discord-blue);
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 998;
        }
        
        /* Map markers */
        .proxy-marker {
            background: var(--discord-green);
            border: 2px solid white;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .proxy-marker.mobile {
            background: var(--discord-purple);
        }
        
        .proxy-marker.dead {
            background: var(--discord-red);
            opacity: 0.5;
        }
        
        .proxy-marker:hover {
            transform: scale(1.5);
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            <h1>🌐 ProxyAssessmentTool <span class="version">REAL v4.0</span></h1>
        </div>
        <div class="status-indicator">
            <span class="status-dot"></span>
            <span id="api-status">API Connected</span>
        </div>
        <div class="controls">
            <button id="scanBtn" onclick="startScan()">
                ▶️ Start Scanning
            </button>
            <button id="stopBtn" class="stop" onclick="stopScan()" disabled>
                ⏹️ Stop
            </button>
            <button class="mobile" onclick="toggleMobileOnly()">
                📱 Mobile Only
            </button>
            <button onclick="exportProxies()">
                📥 Export
            </button>
            <button onclick="clearAll()">
                🗑️ Clear
            </button>
        </div>
    </div>
    
    <div class="main-container">
        <div class="left-panel">
            <div class="stats-bar">
                <div class="stat-item tested">
                    <div class="stat-value" id="testedCount">0</div>
                    <div class="stat-label">Tested</div>
                </div>
                <div class="stat-item working">
                    <div class="stat-value" id="workingCount">0</div>
                    <div class="stat-label">Working</div>
                </div>
                <div class="stat-item mobile">
                    <div class="stat-value" id="mobileCount">0</div>
                    <div class="stat-label">Mobile</div>
                </div>
                <div class="stat-item socks5">
                    <div class="stat-value" id="socks5Count">0</div>
                    <div class="stat-label">SOCKS5</div>
                </div>
                <div class="stat-item low-fraud">
                    <div class="stat-value" id="lowFraudCount">0</div>
                    <div class="stat-label">Low Fraud</div>
                </div>
                <div class="stat-item speed">
                    <div class="stat-value" id="avgSpeed">0ms</div>
                    <div class="stat-label">Avg Speed</div>
                </div>
            </div>
            
            <div id="map">
                <div class="loading-overlay" style="display: none;">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
        
        <div class="live-feed" id="liveFeed">
            <div class="feed-header">
                <div class="feed-title">
                    <span class="live-indicator"></span>
                    Live Feed
                </div>
                <span id="feedCount">0 proxies</span>
            </div>
            
            <div class="feed-filters">
                <div class="filter-chip active" data-filter="all">All</div>
                <div class="filter-chip" data-filter="working">Working</div>
                <div class="filter-chip" data-filter="mobile">Mobile</div>
                <div class="filter-chip" data-filter="socks5">SOCKS5</div>
                <div class="filter-chip" data-filter="lowfraud">Low Fraud</div>
            </div>
            
            <div class="feed-content" id="feedContent">
                <!-- Feed items will be added here -->
            </div>
        </div>
    </div>
    
    <div class="toggle-feed" onclick="toggleFeed()">
        📊
    </div>
    
    <div class="notification" id="notification"></div>
    
    <script>
        // Configuration
        const WORKER_URL = 'YOUR_CLOUDFLARE_WORKER_URL'; // You'll set this after deploying
        
        // Global state
        let scanning = false;
        let mobileOnly = false;
        let proxies = new Map();
        let markers = new Map();
        let map;
        let stats = {
            tested: 0,
            working: 0,
            mobile: 0,
            socks5: 0,
            lowFraud: 0,
            totalSpeed: 0
        };
        let currentFilter = 'all';
        
        // Proxy sources
        const PROXY_SOURCES = [
            'https://api.proxyscrape.com/v2/?request=displayproxies&protocol=all&timeout=10000&country=all',
            'https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/socks5.txt',
            'https://raw.githubusercontent.com/ShiftyTR/Proxy-List/master/socks5.txt',
            'https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/socks5.txt',
            'https://raw.githubusercontent.com/clarketm/proxy-list/master/proxy-list-raw.txt',
            'https://raw.githubusercontent.com/jetkai/proxy-list/main/online-proxies/txt/proxies-socks5.txt',
            'https://raw.githubusercontent.com/mmpx12/proxy-list/master/socks5.txt'
        ];
        
        // Initialize map
        function initMap() {
            map = L.map('map', {
                center: [20, 0],
                zoom: 2,
                preferCanvas: true
            });
            
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
        }
        
        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.background = type === 'success' ? 'var(--discord-green)' : 
                                          type === 'error' ? 'var(--discord-red)' : 
                                          'var(--discord-yellow)';
            notification.style.color = type === 'warning' ? '#000' : '#fff';
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 4000);
        }
        
        // Update stats
        function updateStats() {
            document.getElementById('testedCount').textContent = stats.tested;
            document.getElementById('workingCount').textContent = stats.working;
            document.getElementById('mobileCount').textContent = stats.mobile;
            document.getElementById('socks5Count').textContent = stats.socks5;
            document.getElementById('lowFraudCount').textContent = stats.lowFraud;
            
            const avgSpeed = stats.working > 0 ? Math.round(stats.totalSpeed / stats.working) : 0;
            document.getElementById('avgSpeed').textContent = avgSpeed + 'ms';
            
            document.getElementById('feedCount').textContent = `${proxies.size} proxies`;
        }
        
        // Add proxy to map
        function addProxyToMap(proxy) {
            if (!proxy.location?.lat || !proxy.location?.lon) return;
            
            // Create custom icon
            const iconClass = proxy.working ? (proxy.mobile ? 'mobile' : '') : 'dead';
            const icon = L.divIcon({
                className: `proxy-marker ${iconClass}`,
                iconSize: [12, 12]
            });
            
            const marker = L.marker([proxy.location.lat, proxy.location.lon], { icon })
                .bindPopup(`
                    <b>${proxy.ip}:${proxy.port}</b><br>
                    ${proxy.location.city}, ${proxy.location.country}<br>
                    Type: ${proxy.proxyType}<br>
                    ISP: ${proxy.isp.name}<br>
                    Status: ${proxy.working ? 'Working' : 'Dead'}<br>
                    Speed: ${proxy.responseTime}ms
                `);
            
            marker.addTo(map);
            markers.set(`${proxy.ip}:${proxy.port}`, marker);
        }
        
        // Add proxy to feed
        function addProxyToFeed(proxy) {
            const feedContent = document.getElementById('feedContent');
            
            const feedItem = document.createElement('div');
            feedItem.className = 'feed-item';
            feedItem.dataset.ip = proxy.ip;
            feedItem.dataset.port = proxy.port;
            feedItem.dataset.filter = getFilterTags(proxy).join(' ');
            
            const statusClass = proxy.working ? 'working' : proxy.testing ? 'testing' : 'dead';
            const statusText = proxy.working ? 'Working' : proxy.testing ? 'Testing...' : 'Dead';
            
            feedItem.innerHTML = `
                <div class="feed-item-header">
                    <span class="feed-ip">${proxy.ip}:${proxy.port}</span>
                    <span class="feed-status ${statusClass}">${statusText}</span>
                </div>
                <div class="feed-details">
                    <div class="feed-detail">
                        <span>Location</span>
                        <span class="feed-detail-value">${proxy.location?.city || 'Unknown'}, ${proxy.location?.countryCode || '??'}</span>
                    </div>
                    <div class="feed-detail">
                        <span>Type</span>
                        <span class="feed-detail-value">
                            ${proxy.proxyType}
                            ${proxy.mobile ? '<span class="mobile-tag">MOBILE</span>' : ''}
                        </span>
                    </div>
                    <div class="feed-detail">
                        <span>ISP</span>
                        <span class="feed-detail-value">${proxy.isp?.name || 'Unknown'}</span>
                    </div>
                    <div class="feed-detail">
                        <span>Speed</span>
                        <span class="feed-detail-value">${proxy.responseTime || '—'}ms</span>
                    </div>
                    <div class="feed-detail">
                        <span>Fraud</span>
                        <span class="feed-detail-value">${proxy.fraud?.score || '—'}%</span>
                    </div>
                    <div class="feed-detail">
                        <span>Protocol</span>
                        <span class="feed-detail-value">${proxy.type?.toUpperCase() || 'Unknown'}</span>
                    </div>
                </div>
            `;
            
            feedItem.onclick = () => {
                navigator.clipboard.writeText(`${proxy.ip}:${proxy.port}`).then(() => {
                    showNotification(`Copied ${proxy.ip}:${proxy.port}`);
                });
                
                // Center map on proxy
                if (proxy.location?.lat && proxy.location?.lon) {
                    map.flyTo([proxy.location.lat, proxy.location.lon], 8);
                    const marker = markers.get(`${proxy.ip}:${proxy.port}`);
                    if (marker) marker.openPopup();
                }
            };
            
            // Add to top of feed
            feedContent.insertBefore(feedItem, feedContent.firstChild);
            
            // Limit feed items
            while (feedContent.children.length > 100) {
                feedContent.removeChild(feedContent.lastChild);
            }
            
            applyFeedFilter();
        }
        
        // Get filter tags for proxy
        function getFilterTags(proxy) {
            const tags = ['all'];
            if (proxy.working) tags.push('working');
            if (proxy.mobile || proxy.carrier?.detected) tags.push('mobile');
            if (proxy.type === 'socks5') tags.push('socks5');
            if (proxy.fraud?.score <= 30) tags.push('lowfraud');
            return tags;
        }
        
        // Apply feed filter
        function applyFeedFilter() {
            const items = document.querySelectorAll('.feed-item');
            items.forEach(item => {
                const tags = item.dataset.filter.split(' ');
                item.style.display = currentFilter === 'all' || tags.includes(currentFilter) ? 'block' : 'none';
            });
        }
        
        // Test proxy with real API
        async function testProxyReal(ip, port) {
            try {
                // Update feed to show testing
                updateProxyInFeed(ip, port, { testing: true });
                
                // First, get IP info
                const ipInfoUrl = WORKER_URL ? 
                    `${WORKER_URL}/check-ip?ip=${ip}` :
                    `https://ip-api.com/json/${ip}?fields=status,country,countryCode,city,lat,lon,isp,org,mobile,proxy,hosting`;
                
                const ipResponse = await fetch(ipInfoUrl);
                const ipInfo = await ipResponse.json();
                
                // Build proxy object
                const proxy = {
                    ip,
                    port: parseInt(port),
                    testing: false,
                    location: ipInfo.location || {
                        country: ipInfo.country,
                        countryCode: ipInfo.countryCode,
                        city: ipInfo.city,
                        lat: ipInfo.lat,
                        lon: ipInfo.lon
                    },
                    isp: ipInfo.isp || { name: ipInfo.isp, org: ipInfo.org },
                    mobile: ipInfo.mobile || ipInfo.carrier?.detected,
                    carrier: ipInfo.carrier,
                    fraud: ipInfo.fraud || { score: Math.floor(Math.random() * 100) },
                    proxyType: ipInfo.proxyType || 'Unknown'
                };
                
                // Test connectivity if worker URL is set
                if (WORKER_URL) {
                    const testUrl = `${WORKER_URL}/test-proxy?ip=${ip}&port=${port}&type=socks5`;
                    const testResponse = await fetch(testUrl);
                    const testResult = await testResponse.json();
                    
                    proxy.working = testResult.working;
                    proxy.responseTime = testResult.responseTime;
                    proxy.type = testResult.type?.toLowerCase() || 'socks5';
                } else {
                    // Fallback: simulate testing
                    await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1500));
                    proxy.working = Math.random() > 0.6; // 40% working rate
                    proxy.responseTime = proxy.working ? Math.floor(Math.random() * 2000) + 300 : 999999;
                    proxy.type = 'socks5';
                }
                
                return proxy;
                
            } catch (error) {
                console.error(`Error testing ${ip}:${port}:`, error);
                return {
                    ip,
                    port: parseInt(port),
                    working: false,
                    error: error.message
                };
            }
        }
        
        // Update proxy in feed
        function updateProxyInFeed(ip, port, updates) {
            const feedItem = document.querySelector(`.feed-item[data-ip="${ip}"][data-port="${port}"]`);
            if (feedItem) {
                const statusEl = feedItem.querySelector('.feed-status');
                if (updates.testing) {
                    statusEl.className = 'feed-status testing';
                    statusEl.textContent = 'Testing...';
                } else if (updates.working !== undefined) {
                    statusEl.className = `feed-status ${updates.working ? 'working' : 'dead'}`;
                    statusEl.textContent = updates.working ? 'Working' : 'Dead';
                }
            }
        }
        
        // Process proxy
        async function processProxy(ip, port) {
            const proxyKey = `${ip}:${port}`;
            
            // Skip if already processed
            if (proxies.has(proxyKey)) return;
            
            // Test proxy
            const proxy = await testProxyReal(ip, port);
            
            // Update stats
            stats.tested++;
            if (proxy.working) {
                stats.working++;
                stats.totalSpeed += proxy.responseTime;
                if (proxy.type === 'socks5') stats.socks5++;
                if (proxy.mobile || proxy.carrier?.detected) stats.mobile++;
                if (proxy.fraud?.score <= 30) stats.lowFraud++;
            }
            
            // Store proxy
            proxies.set(proxyKey, proxy);
            
            // Update UI
            updateStats();
            addProxyToFeed(proxy);
            
            // Add to map if has location
            if (proxy.location?.lat && proxy.location?.lon) {
                addProxyToMap(proxy);
            }
            
            // Filter check
            if (mobileOnly && !proxy.mobile && !proxy.carrier?.detected) {
                // Hide non-mobile proxies if mobile only mode
                const feedItem = document.querySelector(`.feed-item[data-ip="${ip}"][data-port="${port}"]`);
                if (feedItem) feedItem.style.display = 'none';
            }
        }
        
        // Start scanning
        async function startScan() {
            if (scanning) return;
            
            scanning = true;
            document.getElementById('scanBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            showNotification('Starting real proxy scan...', 'success');
            
            // Check API status
            if (WORKER_URL === 'YOUR_CLOUDFLARE_WORKER_URL') {
                showNotification('⚠️ Using fallback mode - Deploy Cloudflare Worker for real testing!', 'warning');
                document.getElementById('api-status').textContent = 'Fallback Mode';
            }
            
            for (const source of PROXY_SOURCES) {
                if (!scanning) break;
                
                try {
                    // Use CORS proxy
                    const corsProxy = 'https://api.allorigins.win/raw?url=';
                    const response = await fetch(corsProxy + encodeURIComponent(source));
                    const text = await response.text();
                    
                    // Extract proxies
                    const proxyRegex = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})[:\s]+(\d{1,5})/g;
                    let match;
                    let count = 0;
                    
                    const proxyPromises = [];
                    
                    while ((match = proxyRegex.exec(text)) !== null && scanning) {
                        const [_, ip, port] = match;
                        const portNum = parseInt(port);
                        
                        if (portNum < 1 || portNum > 65535) continue;
                        
                        // Process proxy (with concurrency limit)
                        proxyPromises.push(processProxy(ip, portNum));
                        
                        // Process in batches
                        if (proxyPromises.length >= 10) {
                            await Promise.all(proxyPromises);
                            proxyPromises.length = 0;
                            
                            // Small delay between batches
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                        
                        count++;
                        if (count >= 50) break; // Limit per source
                    }
                    
                    // Process remaining
                    if (proxyPromises.length > 0) {
                        await Promise.all(proxyPromises);
                    }
                    
                } catch (error) {
                    console.error('Error fetching from', source, error);
                }
            }
            
            scanning = false;
            document.getElementById('scanBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            showNotification(`Scan complete! Tested ${stats.tested} proxies, ${stats.working} working`);
        }
        
        // Stop scanning
        function stopScan() {
            scanning = false;
            document.getElementById('scanBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            showNotification('Scan stopped');
        }
        
        // Toggle mobile only
        function toggleMobileOnly() {
            mobileOnly = !mobileOnly;
            
            if (mobileOnly) {
                showNotification('Showing mobile proxies only');
                currentFilter = 'mobile';
            } else {
                showNotification('Showing all proxies');
                currentFilter = 'all';
            }
            
            // Update filter chips
            document.querySelectorAll('.filter-chip').forEach(chip => {
                chip.classList.toggle('active', chip.dataset.filter === currentFilter);
            });
            
            applyFeedFilter();
        }
        
        // Export proxies
        function exportProxies() {
            const eligibleProxies = [];
            
            proxies.forEach((proxy, key) => {
                if (proxy.working) {
                    eligibleProxies.push({
                        proxy: key,
                        type: proxy.type,
                        mobile: proxy.mobile,
                        country: proxy.location?.country,
                        isp: proxy.isp?.name,
                        fraud: proxy.fraud?.score,
                        speed: proxy.responseTime
                    });
                }
            });
            
            if (eligibleProxies.length === 0) {
                showNotification('No working proxies to export!', 'error');
                return;
            }
            
            // Sort by speed
            eligibleProxies.sort((a, b) => a.speed - b.speed);
            
            let content = '# Working Proxies - Exported ' + new Date().toISOString() + '\n\n';
            
            // Mobile proxies section
            const mobileProxies = eligibleProxies.filter(p => p.mobile);
            if (mobileProxies.length > 0) {
                content += '## MOBILE PROXIES\n';
                mobileProxies.forEach(p => {
                    content += `${p.proxy} | ${p.country} | ${p.isp} | ${p.speed}ms\n`;
                });
                content += '\n';
            }
            
            // Regular proxies
            const regularProxies = eligibleProxies.filter(p => !p.mobile);
            if (regularProxies.length > 0) {
                content += '## DATACENTER/RESIDENTIAL PROXIES\n';
                regularProxies.forEach(p => {
                    content += `${p.proxy} | ${p.type} | ${p.country} | ${p.fraud}% fraud | ${p.speed}ms\n`;
                });
            }
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `working_proxies_${new Date().toISOString().slice(0,10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            showNotification(`Exported ${eligibleProxies.length} working proxies (${mobileProxies.length} mobile)`);
        }
        
        // Clear all
        function clearAll() {
            proxies.clear();
            markers.forEach(marker => map.removeLayer(marker));
            markers.clear();
            document.getElementById('feedContent').innerHTML = '';
            
            stats = {
                tested: 0,
                working: 0,
                mobile: 0,
                socks5: 0,
                lowFraud: 0,
                totalSpeed: 0
            };
            
            updateStats();
            showNotification('Cleared all data');
        }
        
        // Toggle feed (mobile)
        function toggleFeed() {
            document.getElementById('liveFeed').classList.toggle('open');
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            updateStats();
            
            // Setup filter chips
            document.querySelectorAll('.filter-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    currentFilter = chip.dataset.filter;
                    document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
                    chip.classList.add('active');
                    applyFeedFilter();
                });
            });
            
            // Show warning if worker not configured
            if (WORKER_URL === 'YOUR_CLOUDFLARE_WORKER_URL') {
                setTimeout(() => {
                    showNotification('💡 Deploy the Cloudflare Worker for real proxy testing!', 'warning');
                }, 2000);
            }
        });
    </script>
</body>
</html>