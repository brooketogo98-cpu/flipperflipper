/**
 * Settings management with type safety and persistence
 */

export interface Settings {
  // Max Auto Engine
  automation: {
    enabled: boolean;
    scanInterval: number; // minutes
    maxTabsPerBatch: number;
    pauseDuringActive: boolean;
    idleThreshold: number; // seconds
  };
  
  // Search preferences
  search: {
    defaultRadius: number; // miles
    minPrice: number;
    maxPrice: number;
    excludeKeywords: string[];
    preferredPlatforms: string[];
  };
  
  // Pricing settings
  pricing: {
    defaultMargin: number; // percentage
    includeShipping: boolean;
    includeFees: boolean;
    taxRate: number;
    pricingStrategy: 'aggressive' | 'moderate' | 'conservative';
  };
  
  // Communication
  messaging: {
    defaultTemplate: string;
    autoGenerateDraft: boolean;
    responseTimeout: number; // hours
    followUpCadence: number[]; // hours
  };
  
  // Risk management
  risk: {
    maxRiskScore: number;
    autoRejectHighRisk: boolean;
    riskFactors: {
      noPhotos: number;
      newSeller: number;
      tooGoodToBeTrue: number;
      missingSpecs: number;
    };
  };
  
  // Notifications
  notifications: {
    enabled: boolean;
    newDeals: boolean;
    priceDrops: boolean;
    messages: boolean;
    updates: boolean;
    sound: boolean;
  };
  
  // Privacy
  privacy: {
    analytics: boolean;
    crashReports: boolean;
    encryptBackups: boolean;
    autoDeleteOldData: number; // days
  };
  
  // UI preferences
  ui: {
    theme: 'light' | 'dark' | 'system';
    compactMode: boolean;
    showMetrics: boolean;
    defaultView: 'grid' | 'list' | 'kanban';
  };
}

// Default settings
export const DEFAULT_SETTINGS: Settings = {
  automation: {
    enabled: false,
    scanInterval: 30,
    maxTabsPerBatch: 3,
    pauseDuringActive: true,
    idleThreshold: 300
  },
  search: {
    defaultRadius: 25,
    minPrice: 100,
    maxPrice: 5000,
    excludeKeywords: ['parts', 'broken', 'repair'],
    preferredPlatforms: ['facebook', 'craigslist', 'offerup']
  },
  pricing: {
    defaultMargin: 25,
    includeShipping: true,
    includeFees: true,
    taxRate: 8.5,
    pricingStrategy: 'moderate'
  },
  messaging: {
    defaultTemplate: 'default',
    autoGenerateDraft: true,
    responseTimeout: 24,
    followUpCadence: [24, 48, 96]
  },
  risk: {
    maxRiskScore: 0.7,
    autoRejectHighRisk: false,
    riskFactors: {
      noPhotos: 0.3,
      newSeller: 0.2,
      tooGoodToBeTrue: 0.4,
      missingSpecs: 0.2
    }
  },
  notifications: {
    enabled: true,
    newDeals: true,
    priceDrops: true,
    messages: true,
    updates: true,
    sound: false
  },
  privacy: {
    analytics: true,
    crashReports: true,
    encryptBackups: true,
    autoDeleteOldData: 90
  },
  ui: {
    theme: 'system',
    compactMode: false,
    showMetrics: true,
    defaultView: 'grid'
  }
};

// Settings manager class
export class SettingsManager {
  private static instance: SettingsManager;
  private settings: Settings = DEFAULT_SETTINGS;
  private listeners: Set<(settings: Settings) => void> = new Set();

  private constructor() {
    this.loadSettings();
  }

  static getInstance(): SettingsManager {
    if (!SettingsManager.instance) {
      SettingsManager.instance = new SettingsManager();
    }
    return SettingsManager.instance;
  }

  async loadSettings(): Promise<void> {
    try {
      const stored = await chrome.storage.local.get(['settings']);
      if (stored.settings) {
        this.settings = this.mergeSettings(DEFAULT_SETTINGS, stored.settings);
      }
    } catch (error) {
      console.error('Failed to load settings:', error);
    }
  }

  async saveSettings(updates: Partial<Settings>): Promise<void> {
    this.settings = this.mergeSettings(this.settings, updates);
    await chrome.storage.local.set({ settings: this.settings });
    
    // Notify listeners
    this.listeners.forEach(listener => listener(this.settings));
    
    // Send message to background
    chrome.runtime.sendMessage({
      action: 'SETTINGS_UPDATED',
      settings: this.settings
    });
  }

  getSettings(): Settings {
    return { ...this.settings };
  }

  getSetting<K extends keyof Settings>(key: K): Settings[K] {
    return { ...this.settings[key] };
  }

  async updateSetting<K extends keyof Settings>(
    key: K,
    value: Partial<Settings[K]>
  ): Promise<void> {
    const updates = {
      [key]: { ...this.settings[key], ...value }
    } as Partial<Settings>;
    
    await this.saveSettings(updates);
  }

  subscribe(listener: (settings: Settings) => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  // Deep merge settings objects
  private mergeSettings<T extends object>(base: T, updates: Partial<T>): T {
    const result = { ...base };
    
    for (const key in updates) {
      if (updates[key] !== undefined) {
        if (typeof updates[key] === 'object' && !Array.isArray(updates[key])) {
          result[key] = this.mergeSettings(
            base[key] as any,
            updates[key] as any
          );
        } else {
          result[key] = updates[key] as any;
        }
      }
    }
    
    return result;
  }

  // Reset to defaults
  async resetSettings(): Promise<void> {
    await this.saveSettings(DEFAULT_SETTINGS);
  }

  // Export settings
  exportSettings(): string {
    return JSON.stringify(this.settings, null, 2);
  }

  // Import settings
  async importSettings(json: string): Promise<void> {
    try {
      const imported = JSON.parse(json);
      const validated = this.mergeSettings(DEFAULT_SETTINGS, imported);
      await this.saveSettings(validated);
    } catch (error) {
      throw new Error('Invalid settings format');
    }
  }
}

// Singleton instance
export const settingsManager = SettingsManager.getInstance();